/**
 * Format Converters
 * Convert dembrandt output to various formats
 */

/**
 * Generate DESIGN.md (human-readable markdown)
 */
export function toDesignMD(data, url) {
  const siteName = new URL(url).hostname.replace('www.', '');
  const date = new Date().toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  let md = `# Design System: ${siteName}\n\n`;
  md += `*Extracted: ${date} | Source: ${url}*\n\n`;
  md += `---\n\n`;

  // Colors section
  if (data.colors?.palette?.length) {
    md += `## ðŸŽ¨ Color Palette\n\n`;
    
    const highConfidence = data.colors.palette.filter(c => c.confidence === 'high');
    const mediumConfidence = data.colors.palette.filter(c => c.confidence === 'medium');
    
    if (highConfidence.length) {
      md += `### Primary Colors\n`;
      highConfidence.forEach(color => {
        const context = color.context ? ` (${color.context})` : '';
        md += `- **${color.value}**${context}\n`;
      });
      md += `\n`;
    }
    
    if (mediumConfidence.length) {
      md += `### Secondary Colors\n`;
      mediumConfidence.forEach(color => {
        const context = color.context ? ` (${color.context})` : '';
        md += `- ${color.value}${context}\n`;
      });
      md += `\n`;
    }
  }

  // Typography section
  if (data.typography?.fonts?.length) {
    md += `## ðŸ”¤ Typography\n\n`;
    data.typography.fonts.forEach(font => {
      md += `### ${font.family}\n`;
      if (font.weights?.length) {
        md += `- **Weights:** ${font.weights.join(', ')}\n`;
      }
      if (font.sizes?.length) {
        md += `- **Sizes:** ${font.sizes.join(', ')}\n`;
      }
      if (font.source) {
        md += `- **Source:** ${font.source}\n`;
      }
      md += `\n`;
    });
  }

  // Spacing section
  if (data.spacing?.scale?.length) {
    md += `## ðŸ“ Spacing Scale\n\n`;
    if (data.spacing.base) {
      md += `**Base Unit:** ${data.spacing.base}\n\n`;
    }
    md += `**Scale:** ${data.spacing.scale.join(' â€¢ ')}\n\n`;
  }

  // Shadows section
  if (data.shadows?.length) {
    md += `## âœ¨ Shadows\n\n`;
    data.shadows.slice(0, 5).forEach((shadow, i) => {
      md += `${i + 1}. \`${shadow.value}\`\n`;
    });
    md += `\n`;
  }

  // Border Radius section
  if (data.borderRadius?.length) {
    md += `## ðŸ”² Border Radius\n\n`;
    md += `**Values:** ${data.borderRadius.map(r => r.value).join(' â€¢ ')}\n\n`;
  }

  // Borders section
  if (data.borders?.length) {
    md += `## ðŸ“ Borders\n\n`;
    data.borders.slice(0, 5).forEach((border, i) => {
      md += `${i + 1}. ${border.width} ${border.style || 'solid'} ${border.color || ''}\n`;
    });
    md += `\n`;
  }

  // Components section
  if (data.buttons?.length) {
    md += `## ðŸŽ¯ Button Styles\n\n`;
    data.buttons.slice(0, 3).forEach((btn, i) => {
      md += `### Variant ${i + 1}\n`;
      if (btn.backgroundColor) md += `- Background: ${btn.backgroundColor}\n`;
      if (btn.color) md += `- Text Color: ${btn.color}\n`;
      if (btn.padding) md += `- Padding: ${btn.padding}\n`;
      if (btn.borderRadius) md += `- Border Radius: ${btn.borderRadius}\n`;
      if (btn.fontSize) md += `- Font Size: ${btn.fontSize}\n`;
      md += `\n`;
    });
  }

  // Links section
  if (data.links?.length) {
    md += `## ðŸ”— Link Styles\n\n`;
    const link = data.links[0];
    if (link.color) md += `- **Color:** ${link.color}\n`;
    if (link.hoverColor) md += `- **Hover:** ${link.hoverColor}\n`;
    if (link.textDecoration) md += `- **Decoration:** ${link.textDecoration}\n`;
    md += `\n`;
  }

  // Breakpoints section
  if (data.breakpoints?.length) {
    md += `## ðŸ“± Breakpoints\n\n`;
    data.breakpoints.forEach(bp => {
      md += `- **${bp.name || 'Breakpoint'}:** ${bp.value}\n`;
    });
    md += `\n`;
  }

  // Frameworks section
  if (data.frameworks?.length) {
    md += `## ðŸ› ï¸ Detected Frameworks\n\n`;
    data.frameworks.forEach(fw => {
      md += `- ${fw.name}${fw.version ? ` (${fw.version})` : ''}\n`;
    });
    md += `\n`;
  }

  md += `---\n\n`;
  md += `*Generated by Design Dropper â€¢ [Get the extension](https://chrome.google.com/webstore)*\n`;

  return md;
}

/**
 * Generate CSS Variables
 */
export function toCSSVariables(data) {
  let css = ':root {\n';
  css += '  /* Design Dropper - Extracted CSS Variables */\n\n';

  // Colors
  if (data.colors?.palette?.length) {
    css += '  /* Colors */\n';
    data.colors.palette.forEach((color, i) => {
      const name = color.context 
        ? color.context.toLowerCase().replace(/\s+/g, '-')
        : `color-${i + 1}`;
      css += `  --${name}: ${color.value};\n`;
    });
    css += '\n';
  }

  // Typography
  if (data.typography?.fonts?.length) {
    css += '  /* Typography */\n';
    data.typography.fonts.forEach((font, i) => {
      const name = font.family.toLowerCase().replace(/\s+/g, '-');
      css += `  --font-${name}: ${font.family};\n`;
      
      if (font.sizes?.length) {
        font.sizes.forEach((size, j) => {
          css += `  --font-size-${i + 1}-${j + 1}: ${size};\n`;
        });
      }
    });
    css += '\n';
  }

  // Spacing
  if (data.spacing?.scale?.length) {
    css += '  /* Spacing */\n';
    if (data.spacing.base) {
      css += `  --spacing-base: ${data.spacing.base};\n`;
    }
    data.spacing.scale.forEach((value, i) => {
      css += `  --spacing-${i + 1}: ${value};\n`;
    });
    css += '\n';
  }

  // Shadows
  if (data.shadows?.length) {
    css += '  /* Shadows */\n';
    data.shadows.slice(0, 5).forEach((shadow, i) => {
      css += `  --shadow-${i + 1}: ${shadow.value};\n`;
    });
    css += '\n';
  }

  // Border Radius
  if (data.borderRadius?.length) {
    css += '  /* Border Radius */\n';
    data.borderRadius.forEach((radius, i) => {
      css += `  --radius-${i + 1}: ${radius.value};\n`;
    });
    css += '\n';
  }

  css += '}\n';
  return css;
}

/**
 * Generate Tailwind Config
 */
export function toTailwindConfig(data) {
  const config = {
    theme: {
      extend: {}
    }
  };

  // Colors
  if (data.colors?.palette?.length) {
    config.theme.extend.colors = {};
    data.colors.palette.forEach((color, i) => {
      const name = color.context 
        ? color.context.toLowerCase().replace(/\s+/g, '-')
        : `color-${i + 1}`;
      config.theme.extend.colors[name] = color.value;
    });
  }

  // Typography
  if (data.typography?.fonts?.length) {
    config.theme.extend.fontFamily = {};
    data.typography.fonts.forEach((font, i) => {
      const name = font.family.toLowerCase().replace(/\s+/g, '-');
      config.theme.extend.fontFamily[name] = [font.family, 'sans-serif'];
    });
  }

  // Spacing
  if (data.spacing?.scale?.length) {
    config.theme.extend.spacing = {};
    data.spacing.scale.forEach((value, i) => {
      config.theme.extend.spacing[`spacing-${i + 1}`] = value;
    });
  }

  // Shadows
  if (data.shadows?.length) {
    config.theme.extend.boxShadow = {};
    data.shadows.slice(0, 5).forEach((shadow, i) => {
      config.theme.extend.boxShadow[`shadow-${i + 1}`] = shadow.value;
    });
  }

  // Border Radius
  if (data.borderRadius?.length) {
    config.theme.extend.borderRadius = {};
    data.borderRadius.forEach((radius, i) => {
      config.theme.extend.borderRadius[`radius-${i + 1}`] = radius.value;
    });
  }

  return `/** @type {import('tailwindcss').Config} */\nmodule.exports = ${JSON.stringify(config, null, 2)};\n`;
}
